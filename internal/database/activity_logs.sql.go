// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: activity_logs.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteActivity = `-- name: DeleteActivity :exec
DELETE FROM all_activities WHERE id = $1
`

func (q *Queries) DeleteActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteActivity, id)
	return err
}

const getActivities = `-- name: GetActivities :many
(
    SELECT a.activity_id, a.name, a.points,aa.type 
    FROM activities a
    JOIN all_activities aa ON a.activity_id = aa.id
    WHERE aa.type = 'default'
)
UNION ALL
(
 SELECT  ca.activity_id,ca.name, ca.points, aa.type
    FROM custom_activities ca
    JOIN all_activities aa ON ca.activity_id = aa.id
    WHERE aa.type = 'custom' AND ca.user_id = $1  
)
ORDER BY points DESC
`

type GetActivitiesRow struct {
	ActivityID uuid.UUID
	Name       string
	Points     int32
	Type       string
}

func (q *Queries) GetActivities(ctx context.Context, userID uuid.UUID) ([]GetActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivities, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivitiesRow
	for rows.Next() {
		var i GetActivitiesRow
		if err := rows.Scan(
			&i.ActivityID,
			&i.Name,
			&i.Points,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyActivityLogs = `-- name: GetDailyActivityLogs :many
SELECT
    al.activity_id,
    al.points,
    al.duration,
    al.start_time,
    al.end_time,
    CASE
        WHEN aa.type = 'custom' THEN ca.name
        WHEN aa.type = 'default' THEN a.name
    END AS activity_name
FROM
    activity_logs al
JOIN
    all_activities aa ON al.activity_id = aa.id
LEFT JOIN
    custom_activities ca ON aa.id = ca.activity_id AND aa.type = 'custom'
LEFT JOIN
    activities a ON aa.id = a.activity_id AND aa.type = 'default'
WHERE
    al.user_id = $1
    AND al.logged_at::date = CURRENT_DATE
`

type GetDailyActivityLogsRow struct {
	ActivityID   uuid.UUID
	Points       int32
	Duration     int32
	StartTime    time.Time
	EndTime      time.Time
	ActivityName interface{}
}

func (q *Queries) GetDailyActivityLogs(ctx context.Context, userID uuid.UUID) ([]GetDailyActivityLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyActivityLogs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyActivityLogsRow
	for rows.Next() {
		var i GetDailyActivityLogsRow
		if err := rows.Scan(
			&i.ActivityID,
			&i.Points,
			&i.Duration,
			&i.StartTime,
			&i.EndTime,
			&i.ActivityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyPoints = `-- name: GetDailyPoints :one
SELECT 
  COALESCE((SELECT SUM(al.points) 
            FROM activity_logs al 
            WHERE al.user_id = $1 
              AND DATE(al.logged_at) = CURRENT_DATE), 0) AS total_points,
  COALESCE((SELECT g.goal_points 
            FROM user_goals g 
            WHERE g.user_id = $1 
              AND DATE(g.goal_date) = CURRENT_DATE), 0) AS goal_points
`

type GetDailyPointsRow struct {
	TotalPoints interface{}
	GoalPoints  interface{}
}

func (q *Queries) GetDailyPoints(ctx context.Context, userID uuid.UUID) (GetDailyPointsRow, error) {
	row := q.db.QueryRowContext(ctx, getDailyPoints, userID)
	var i GetDailyPointsRow
	err := row.Scan(&i.TotalPoints, &i.GoalPoints)
	return i, err
}

const setActivityLog = `-- name: SetActivityLog :one
INSERT INTO activity_logs (id , user_id , activity_id , duration , points , logged_at , start_time  , end_time) VALUES ($1 , $2 , $3 , $4 , $5 , $6 , $7  ,$8) RETURNING id, user_id, activity_id, duration, points, logged_at, start_time, end_time
`

type SetActivityLogParams struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	ActivityID uuid.UUID
	Duration   int32
	Points     int32
	LoggedAt   time.Time
	StartTime  time.Time
	EndTime    time.Time
}

func (q *Queries) SetActivityLog(ctx context.Context, arg SetActivityLogParams) (ActivityLog, error) {
	row := q.db.QueryRowContext(ctx, setActivityLog,
		arg.ID,
		arg.UserID,
		arg.ActivityID,
		arg.Duration,
		arg.Points,
		arg.LoggedAt,
		arg.StartTime,
		arg.EndTime,
	)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ActivityID,
		&i.Duration,
		&i.Points,
		&i.LoggedAt,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const setAllActivity = `-- name: SetAllActivity :exec
 
INSERT INTO all_activities (id, type) VALUES ($1 , $2)
`

type SetAllActivityParams struct {
	ID   uuid.UUID
	Type string
}

func (q *Queries) SetAllActivity(ctx context.Context, arg SetAllActivityParams) error {
	_, err := q.db.ExecContext(ctx, setAllActivity, arg.ID, arg.Type)
	return err
}

const setCustomActivity = `-- name: SetCustomActivity :exec
INSERT INTO custom_activities (activity_id , user_id , name , points , created_at) VALUES ($1 , $2 , $3 , $4 , $5)
`

type SetCustomActivityParams struct {
	ActivityID uuid.UUID
	UserID     uuid.UUID
	Name       string
	Points     int32
	CreatedAt  time.Time
}

func (q *Queries) SetCustomActivity(ctx context.Context, arg SetCustomActivityParams) error {
	_, err := q.db.ExecContext(ctx, setCustomActivity,
		arg.ActivityID,
		arg.UserID,
		arg.Name,
		arg.Points,
		arg.CreatedAt,
	)
	return err
}
